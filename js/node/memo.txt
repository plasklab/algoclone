ブロックや構文解析に必要なクラスはnodeディレクトリにまとめている。
命令ブロックは、node/TSymbol.jsを継承している。
ループ命令は、loop_startとloop_endを一つのブロックとしている。
loop_startクラスとloop_endクラスのインスタンスをloopクラスが管理している。
関数呼び出しの際に、引数が存在すれば、関数呼び出しのブロックにarg_startブロックとarg_endブロックが表示される。
arg_start、arg_endブロックはargクラスに管理されている。

命令ブロックは双方向連結リストで管理している。
ただし、arg_startの前には関数呼び出しブロックかarg_endしか入らない。

main関数に該当する連結リストのヘッドにブロックが一つでも存在すれば、プログラムの実行準備に入る。
編集していた連結リストは、画面下に移動し、実行中のブロックをハイライトするためのプログラムを表示する。
parser.jsのmain_parserとfunc_parserを実行し、mainと関数の構文解析を行う。
関数の構文解析の結果は、func_mapクラスのインスタンスで管理しする。
mainの構文解析の結果と初期化したstateインスタンスとfunc_mapのインスンタンスを引数にインタプリタで実行する。

stateインスタンスでは、画面に表示されているplayerのインスタンス、playerがマップの衝突しているかどうかの真偽値、スタックフレームを管理している。

スタックフレームでは、main_frame、func_frame、loop_frameが存在する。
main_frameでは、main_frameのstmtsとプログラムポインタを保持する。
func_frameでは、stmtsとプログラムポインタに加え、関数名に該当するnameを保持する。
loop_frameでは、stmtsとプログラムポインタとループカウンタを保持する。
これらのframeは、main関数、関数の呼び出し時、初めのループの実行時に生成され、stateのスタックフレームにpushされる。
それぞれの処理が終わるとstateのスタックフレームからpopされる。

インタプリタでは、まずスタックフレームのtopのフレームのプログラムポインタでそのフレームの処理が終わっているかを判断する。
終わっていた場合、func_frameであれば、画面から関数のプログラムを削除し、func_frameも削除する。
loop_frameの場合、ループカウンタをデクリメントし0であればフレームを削除する。
0でなければ、プログラムポインタを0にし再びloop_frameをスタックフレームにpushする。
main_frameの場合、stateのplayerの位置とmapのゴールの位置が一致しているかを判定しゴールか再挑戦か判断する。

次にフレームの処理が終わっていない場合、各フレームのプログラムポインタに該当する命令を評価する。

最後に、ブロック実行後のplayerの場所がmapの道以外の場所であればstateの衝突判定の真偽値をtrueに変更しゲームが終了する。

命令の評価では、前進、右回転、左回転、ループ、関数呼び出しがある。
前進は、stateのplayerの座標をplayerの向きを元に移動する。
右回転、左回転は、playerの向きを回転させる。
ループは、loop_frameを作成する。
関数呼び出しは、func_mapのインスタンスから該当する関数の構文木をとり、関数に引数が存在する場合、取り出した構文木中の仮引数と実引数を入れ替え、func_frameを作成する。

